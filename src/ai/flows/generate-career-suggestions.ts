'use server';
/**
 * @fileOverview Generates personalized career suggestions using AI tools for localization.
 *
 * - generateCareerSuggestions - A function that generates career suggestions.
 * - CareerSuggestionsInput - The input type for the generateCareerSuggestions function.
 * - CareerSuggestionsOutput - The return type for the generateCareerSuggestions function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const ContributorResponseSchema = z.object({
  relationship: z.string().describe('The relationship of the contributor to the learner (e.g., Self, Parent, Friend).'),
  interests: z.array(z.string()).describe('The interests of the user.'),
  strengths: z.array(z.string()).describe('The strengths of the user.'),
  workEnvironment: z.string().describe('The preferred work environment of the user.'),
  personalityTraits: z.array(z.string()).describe('The personality traits of the user.'),
  values: z.array(z.string()).describe('The values of the user.'),
  learningStyle: z.array(z.string()).describe('The learning style of the user.'),
});

const CareerSuggestionsInputSchema = z.object({
  contributorResponses: z.array(ContributorResponseSchema).describe('An array of responses from various contributors.'),
  country: z.string().describe('The country the user resides in.'),
  region: z.string().describe('The state or province the user resides in.'),
  highSchool: z.string().describe('The high school the user attends.'),
});
export type CareerSuggestionsInput = z.infer<typeof CareerSuggestionsInputSchema>;

const TimelineStageSchema = z.object({
    stage: z.string(),
    duration: z.string(),
    focus: z.string(),
    details: z.string(),
    salary: z.string().nullable().describe('The expected *monthly* salary range for this career stage, if applicable (e.g., for post-education roles). This should be localized based on the user\'s country. For stages where a salary is not applicable (like High School or University), this MUST be `null`.'),
});

const CareerSchema = z.object({
    title: z.string().describe('The title of the career suggestion.'),
    description: z.string().describe('A short description of the career. For the primary recommendation, include two simple, concrete examples of roles or specializations to make it less broad.'),
    reasoning: z.string().describe('The reasoning for suggesting this career based on the user input.'),
    matchPercentage: z.number().describe('A percentage indicating how well the career matches the user.'),
    timeline: z.array(TimelineStageSchema).describe("A detailed timeline of the user's journey to this career, covering all stages from high school to a senior-level position."),
    subjects: z.array(z.string()).describe('Recommended high school subjects for this career path.'),
    hobbies: z.array(z.string()).describe('Recommended hobbies that complement this career and promote a balanced life.'),
    salary: z.string().describe('The expected *annual* salary range for this career in the specified country. This should be generated by the getSalaryData tool.'),
    growth: z.string().describe('The growth outlook for this career.'),
    workEnvironment: z.string().describe('The typical work environment for this career.'),
    dailyTasks: z.array(z.string()).describe('A list of common daily tasks for someone in this career.'),
    industry: z.string().describe('The primary industry for this career (e.g., "Information Technology and Services", "Healthcare", "Financial Services"). This should be a category that works well for a LinkedIn company search.'),
});

const InsightsSchema = z.object({
    personalityType: z.string().describe("A descriptive title for the user's personality (e.g., 'The Creative Problem-Solver'). This MUST end with a period."),
    strengths: z.array(z.string()).describe("A list of the user's key strengths. Do NOT add a period at the end of each item."),
    motivations: z.array(z.string()).describe("A list of the user's primary motivations. Do NOT add a period at the end of each item."),
    workStyle: z.string().describe("A description of the user's ideal work style. This MUST end with a period."),
    stressFactors: z.array(z.string()).describe("A list of potential stress factors for the user. Do NOT add a period at the end of each item."),
    idealEnvironment: z.string().describe("A description of the user's ideal work environment. This MUST end with a period."),
    leadershipStyle: z.string().describe("A description of the user's potential leadership style. This MUST end with a period."),
});


const CareerSuggestionsOutputSchema = z.object({
  careerSuggestions: z.array(CareerSchema).length(3).describe('A list of exactly 3 career suggestions, from best match to third best match.'),
  insights: InsightsSchema.describe("A summary of the user's personality and work style based on their answers. Follow the punctuation rules in the InsightsSchema descriptions: end all single-string fields with a period, but do not add periods to items in string arrays."),
});
export type CareerSuggestionsOutput = z.infer<typeof CareerSuggestionsOutputSchema>;


const getSalaryData = ai.defineTool(
    {
      name: 'getSalaryData',
      description: 'Provides localized annual and monthly salary estimates for a given career title and country.',
      inputSchema: z.object({
        careerTitle: z.string().describe('The title of the career, e.g., "Software Engineer".'),
        country: z.string().describe('The country for which to provide the salary, e.g., "Canada".'),
      }),
      outputSchema: z.object({
        annual: z.string(),
        monthly: z.string(),
      }),
    },
    async ({ careerTitle, country }) => {
      const baseSalaries: Record<string, { base: number, currency: string, symbol: string }> = {
        "Canada": { base: 90000, currency: "CAD", symbol: "$" },
        "USA": { base: 100000, currency: "USD", symbol: "$" },
        "UK": { base: 60000, currency: "GBP", symbol: "Â£" },
        "Australia": { base: 95000, currency: "AUD", symbol: "$" },
        "South Africa": { base: 600000, currency: "ZAR", symbol: "R" },
        "default": { base: 70000, currency: "USD", symbol: "$" }
      };
      
      const countryKey = Object.keys(baseSalaries).find(k => k.toLowerCase() === country.toLowerCase()) || "default";
      const countryData = baseSalaries[countryKey];

      const annualSalary = countryData.base + (careerTitle.length % 5) * 5000;
      const lowAnnual = annualSalary * 0.8;
      const highAnnual = annualSalary * 1.5;

      const lowMonthly = Math.round(lowAnnual / 12);
      const highMonthly = Math.round(highAnnual / 12);
      
      const annualRange = `${countryData.symbol} ${Math.round(lowAnnual).toLocaleString()} - ${Math.round(highAnnual).toLocaleString()} ${countryData.currency}`;
      const monthlyRange = `${countryData.symbol} ${lowMonthly.toLocaleString()} - ${highMonthly.toLocaleString()} / month`;

      return { annual: annualRange, monthly: monthlyRange };
    }
);

const getSubjectAvailability = ai.defineTool(
    {
      name: 'getSubjectAvailability',
      description: 'Checks which of a list of recommended subjects are likely available at a given high school or in the region.',
      inputSchema: z.object({
        subjects: z.array(z.string()),
        highSchool: z.string(),
        region: z.string(),
        country: z.string(),
      }),
      outputSchema: z.object({
        available: z.array(z.string()),
        unavailable: z.array(z.string()),
      }),
    },
    async ({ subjects }) => {
      const common = ["Mathematics", "English", "Physics", "Biology", "Chemistry", "History", "Art/Design", "Business Studies", "Physical Education", "Computer Science", "Geography", "Social Studies", "Technology"];
      const available: string[] = [];
      const unavailable: string[] = [];
      subjects.forEach(subject => {
        if (common.includes(subject) || Math.random() > 0.3) {
            available.push(subject);
        } else {
            unavailable.push(subject);
        }
      });
      return { available, unavailable };
    }
);


const careerSuggester = ai.definePrompt({
    name: 'careerSuggester',
    model: 'googleai/gemini-1.5-flash-latest',
    input: { schema: CareerSuggestionsInputSchema },
    output: { schema: CareerSuggestionsOutputSchema },
    tools: [getSalaryData, getSubjectAvailability],
    prompt: `You are a world-class career counselor AI named "Career Compass". Your goal is to provide three detailed, inspiring, and actionable career suggestions based on a synthesis of inputs from multiple contributors about a learner. You must also provide a detailed analysis of the learner's personality and work style. IMPORTANT: Do not suggest "Entrepreneur" or "Startup Founder" as a career title. Focus on roles that can be pursued within new or existing companies.

    **Target Audience:** The output MUST be tailored for a 13-16 year old audience. Use clear, simple, and encouraging language. Avoid jargon and explain complex topics in a relatable way.

    **Contributor Profiles & Responses:**
    {{#each contributorResponses}}
    *   **Contributor: {{this.relationship}}**
        *   Interests: {{#if this.interests}} {{#each this.interests}} {{{this}}}{{#unless @last}}, {{/unless}}{{/each}} {{else}}Not provided{{/if}}
        *   Strengths: {{#if this.strengths}} {{#each this.strengths}} {{{this}}}{{#unless @last}}, {{/unless}}{{/each}} {{else}}Not provided{{/if}}
        *   Preferred Work Environment: {{{this.workEnvironment}}}
        *   Personality Traits: {{#if this.personalityTraits}} {{#each this.personalityTraits}} {{{this}}}{{#unless @last}}, {{/unless}}{{/each}} {{else}}Not provided{{/if}}
        *   Values: {{#if this.values}} {{#each this.values}} {{{this}}}{{#unless @last}}, {{/unless}}{{/each}} {{else}}Not provided{{/if}}
        *   Learning Style: {{#if this.learningStyle}} {{#each this.learningStyle}} {{{this}}}{{#unless @last}}, {{/unless}}{{/each}} {{else}}Not provided{{/if}}
    {{/each}}
    *   Location: {{{region}}}, {{{country}}}
    *   High School: {{{highSchool}}}

    **Important Weighting Instructions:**
    *   Synthesize the perspectives from all contributors, but give the most weight to the learner's own answers (relationship: 'Self'), as they are the most direct source of truth. Their input should be considered approximately 50% more influential than 'Friend', 'Teacher', or 'Mentor'.
    *   The parent's answers (relationship: 'Parent') are the second most important. Give their input approximately 30% more weight than other contributors.
    *   When multiple contributors (e.g., the Learner and a Parent) select the same interest, strength, or trait, consider this a very strong signal. This indicates a confirmed area of aptitude or passion that should be heavily emphasized in your analysis and reasoning.

    **Process:**

    1.  **Synthesize User Profile:** Deeply analyze and synthesize the inputs from ALL contributors, applying the weighting instructions above. Look for common themes and also note interesting differences in perspective.
    2.  **Generate Insights:** First, create the 'insights' object. Synthesize the inputs into a cohesive personality profile, including strengths, motivations, and ideal work style. **Important Punctuation Rule:** For any fields that are single strings (like 'personalityType' or 'workStyle'), ensure the string ends with a period. For fields that are arrays of strings (like 'strengths' or 'motivations'), do NOT add a period to each individual item in the array.
    3.  **Brainstorm Careers:** Based on the synthesized profile, brainstorm a list of potential careers. Select the top three best matches.
    4.  **Flesh out each career suggestion:** For EACH of the three careers, you must generate all fields in the CareerSchema. It is **critical** that all text is tailored to a 13-16 year old. This includes:
        *   \`title\`.
        *   A practical and relatable \`description\`. Include two simple, concrete examples of roles or specializations for all three careers (e.g., for "Software Engineer", you could add "Examples: Mobile App Developer who builds apps for iPhones, or a Cloud Infrastructure Engineer who helps Netflix stream movies smoothly.").
        *   \`reasoning\` and \`matchPercentage\`.
        *   A detailed \`timeline\` with at least 4-5 stages. For each stage that is a job (e.g., Junior, Mid-Level, Senior), you MUST include a localized *monthly* \`salary\` range. For stages where a salary is not applicable (like High School or University), you MUST set the \`salary\` field to \`null\`. The \`getSalaryData\` tool returns both an 'annual' and a 'monthly' salary range. Use the 'monthly' salary range as a baseline to estimate the progression for different experience levels.
        *   A list of recommended \`subjects\`.
        *   A list of \`hobbies\` that promote a "work hard, play hard" lifestyle. These hobbies should complement the likely lifestyle and interests of someone in that career, providing a healthy work-life balance.
        *   A list of specific, common \`dailyTasks\`, explained in simple terms a teenager can understand (e.g., instead of "Debugging complex issues", say "Finding and fixing bugs in the code, like a detective solving a puzzle.").
        *   \`growth\` outlook, \`workEnvironment\`, and an \`industry\` suitable for a LinkedIn company search.
    5.  **Use Tools for Localization (IMPORTANT):**
        *   For EACH of the three career suggestions, you MUST use the \`getSalaryData\` tool to get a localized salary. The tool returns an object with 'annual' and 'monthly' properties. You MUST use the 'annual' property for the main \`salary\` field of the career. The 'monthly' property will serve as the baseline for your timeline salary estimates.
        *   After generating the ideal list of recommended \`subjects\` for the PRIMARY career suggestion, you MUST use the \`getSubjectAvailability\` tool to check which are available. In the final output, only include the subjects the tool returns as 'available' in the \`subjects\` array for that primary career. For the other two careers, you can list the ideal subjects without verification.
    7.  **Final Output:** Format the entire response according to the CareerSuggestionsOutputSchema. Ensure there are exactly three career suggestions.
    `,
});

const generateCareerSuggestionsFlow = ai.defineFlow(
    {
      name: 'generateCareerSuggestionsFlow',
      inputSchema: CareerSuggestionsInputSchema,
      outputSchema: CareerSuggestionsOutputSchema,
    },
    async (input) => {
      const {output} = await careerSuggester(input);
      if (!output) {
        throw new Error('Failed to generate career suggestions from the AI model.');
      }
      return output;
    }
);

export async function generateCareerSuggestions(input: CareerSuggestionsInput): Promise<CareerSuggestionsOutput> {
  return await generateCareerSuggestionsFlow(input);
}
