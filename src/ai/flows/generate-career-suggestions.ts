'use server';
/**
 * @fileOverview Generates personalized career suggestions using AI tools for localization.
 *
 * - generateCareerSuggestions - A function that generates career suggestions.
 * - CareerSuggestionsInput - The input type for the generateCareerSuggestions function.
 * - CareerSuggestionsOutput - The return type for the generateCareerSuggestions function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

export const CareerSuggestionsInputSchema = z.object({
  interests: z.array(z.string()).describe('The interests of the user.'),
  strengths: z.array(z.string()).describe('The strengths of the user.'),
  workEnvironment: z.string().describe('The preferred work environment of the user.'),
  personalityTraits: z.array(z.string()).describe('The personality traits of the user.'),
  values: z.array(z.string()).describe('The values of the user.'),
  learningStyle: z.array(z.string()).describe('The learning style of the user.'),
  country: z.string().describe('The country the user resides in.'),
  region: z.string().describe('The state or province the user resides in.'),
  highSchool: z.string().describe('The high school the user attends.'),
});
export type CareerSuggestionsInput = z.infer<typeof CareerSuggestionsInputSchema>;

const TimelineStageSchema = z.object({
    stage: z.string(),
    duration: z.string(),
    focus: z.string(),
    details: z.string(),
});

const CareerSchema = z.object({
    title: z.string().describe('The title of the career suggestion.'),
    description: z.string().describe('A short description of the career.'),
    reasoning: z.string().describe('The reasoning for suggesting this career based on the user input.'),
    matchPercentage: z.number().describe('A percentage indicating how well the career matches the user.'),
    timeline: z.array(TimelineStageSchema).describe("A timeline of the user's journey to this career."),
    subjects: z.array(z.string()).describe('Recommended high school subjects for this career path.'),
    hobbies: z.array(z.string()).describe('Recommended hobbies that complement this career and promote a balanced life.'),
    salary: z.string().describe('The expected salary range for this career in the specified country. This should be generated by the getSalaryData tool.'),
    growth: z.string().describe('The growth outlook for this career.'),
    workEnvironment: z.string().describe('The typical work environment for this career.'),
    dailyTasks: z.array(z.string()).describe('A list of common daily tasks for someone in this career.'),
});

const InsightsSchema = z.object({
    personalityType: z.string(),
    strengths: z.array(z.string()),
    motivations: z.array(z.string()),
    workStyle: z.string(),
    stressFactors: z.array(z.string()),
    idealEnvironment: z.string(),
    leadershipStyle: z.string(),
});

export const CareerSuggestionsOutputSchema = z.object({
  careerSuggestions: z.array(CareerSchema).length(3).describe('A list of exactly 3 career suggestions, from best match to third best match.'),
  insights: InsightsSchema.describe("A summary of the user's personality and work style based on their answers."),
});
export type CareerSuggestionsOutput = z.infer<typeof CareerSuggestionsOutputSchema>;


const getSalaryData = ai.defineTool(
    {
      name: 'getSalaryData',
      description: 'Provides a localized salary estimate for a given career title and country.',
      inputSchema: z.object({
        careerTitle: z.string().describe('The title of the career, e.g., "Software Engineer".'),
        country: z.string().describe('The country for which to provide the salary, e.g., "Canada".'),
      }),
      outputSchema: z.string(),
    },
    async ({ careerTitle, country }) => {
      // This is a mock implementation. In a real app, you would query an API.
      const baseSalaries: Record<string, { base: number, currency: string, symbol: string }> = {
        "Canada": { base: 90000, currency: "CAD", symbol: "$" },
        "USA": { base: 100000, currency: "USD", symbol: "$" },
        "UK": { base: 60000, currency: "GBP", symbol: "Â£" },
        "Australia": { base: 95000, currency: "AUD", symbol: "$" },
        "default": { base: 70000, currency: "USD", symbol: "$" }
      };
      const countryData = baseSalaries[country] || baseSalaries.default;
      const salary = countryData.base + (careerTitle.length % 5) * 5000; // a little variance
      const low = Math.round(salary * 0.8 / 1000) * 1000;
      const high = Math.round(salary * 1.5 / 1000) * 1000;
      return `${countryData.symbol}${low.toLocaleString()} - ${countryData.symbol}${high.toLocaleString()} ${countryData.currency}`;
    }
);

const getSubjectAvailability = ai.defineTool(
    {
      name: 'getSubjectAvailability',
      description: 'Checks which of a list of recommended subjects are likely available at a given high school or in the region.',
      inputSchema: z.object({
        subjects: z.array(z.string()),
        highSchool: z.string(),
        region: z.string(),
        country: z.string(),
      }),
      outputSchema: z.object({
        available: z.array(z.string()),
        unavailable: z.array(z.string()),
      }),
    },
    async ({ subjects }) => {
      // Mock implementation. In a real app, this would be a complex lookup.
      // For this mock, we'll assume common subjects are always available and specialized ones are sometimes not.
      const common = ["Mathematics", "English", "Physics", "Biology", "Chemistry", "History", "Art/Design", "Business Studies", "Physical Education"];
      const available: string[] = [];
      const unavailable: string[] = [];
      subjects.forEach(subject => {
        if (common.includes(subject) || Math.random() > 0.3) {
            available.push(subject);
        } else {
            unavailable.push(subject);
        }
      });
      return { available, unavailable };
    }
);


const careerSuggester = ai.definePrompt({
    name: 'careerSuggester',
    input: { schema: CareerSuggestionsInputSchema },
    output: { schema: CareerSuggestionsOutputSchema },
    tools: [getSalaryData, getSubjectAvailability],
    system: `You are a world-class career counselor AI named "Career Compass". Your goal is to provide three detailed, inspiring, and actionable career suggestions based on the user's profile. You must also provide a detailed analysis of the user's personality and work style.

    **Process:**

    1.  **Analyze User Profile:** Deeply analyze all provided inputs: interests, strengths, work environment preference, personality, values, and learning style.
    2.  **Generate Insights:** First, create the 'insights' object. Synthesize the inputs into a cohesive personality profile, including strengths, motivations, and ideal work style.
    3.  **Brainstorm Careers:** Based on the user profile, brainstorm a list of potential careers. Select the top three best matches.
    4.  **Flesh out each career suggestion:** For EACH of the three careers, you must generate all fields in the CareerSchema. This includes:
        *   \`title\`, \`description\`, \`reasoning\`, \`matchPercentage\`.
        *   A detailed \`timeline\` with at least 3-4 stages.
        *   A list of recommended \`subjects\`.
        *   A list of \`hobbies\` that promote a "work hard, play hard" lifestyle, connecting to the career or providing balance.
        *   \`growth\` outlook, \`workEnvironment\`, and \`dailyTasks\`.
    5.  **Use Tools for Localization (IMPORTANT):**
        *   For EACH of the three career suggestions, you MUST use the \`getSalaryData\` tool to get a localized salary. Pass the career title and the user's country to the tool.
        *   After generating the ideal list of recommended \`subjects\` for the PRIMARY career suggestion, you MUST use the \`getSubjectAvailability\` tool to check which are available. In the final output, only include the subjects the tool returns as 'available' in the \`subjects\` array for that primary career. For the other two careers, you can list the ideal subjects without verification.
    6.  **Final Output:** Format the entire response according to the CareerSuggestionsOutputSchema. Ensure there are exactly three career suggestions.
    `,
});

export async function generateCareerSuggestions(input: CareerSuggestionsInput): Promise<CareerSuggestionsOutput> {
  const {output} = await careerSuggester(input);
  if (!output) {
    throw new Error('Failed to generate career suggestions from the AI model.');
  }
  return output;
}

const generateCareerSuggestionsFlow = ai.defineFlow(
    {
      name: 'generateCareerSuggestionsFlow',
      inputSchema: CareerSuggestionsInputSchema,
      outputSchema: CareerSuggestionsOutputSchema,
    },
    async (input) => {
      const result = await generateCareerSuggestions(input);
      return result;
    }
);
